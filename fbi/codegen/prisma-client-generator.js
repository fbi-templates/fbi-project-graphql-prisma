const { TypescriptGenerator } = require('prisma-client-lib')

module.exports = class PrismaClientGenerator extends TypescriptGenerator {
  constructor ({ schema, typeDefsRelativePath }) {
    super({
      schema
    })
    this.typeDefsRelativePath = typeDefsRelativePath
  }

  render (options, prettifyOptions) {
    const code = this.compile`\
    ${this.renderImports()}

    ${this.renderAtLeastOne()}

    export interface Exists {\n${this.renderExists()}\n}

    export interface Node {}

    export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable

    export interface Fragmentable {
      $fragment<T>(fragment: string | DocumentNode): Promise<T>
    }

    ${this.exportPrisma ? 'export' : ''} interface ${this.prismaInterface} {
      $exists: Exists;
      $graphql: <T ${this.genericsDelimiter} any>(query: string, variables?: {[key: string]: any}) => Promise<T>;

      /**
       * Queries
      */

    ${this.renderQueries()};

      /**
       * Mutations
      */

    ${this.renderMutations()};


      /**
       * Subscriptions
      */

      $subscribe: Subscription

    }

    export interface Subscription {
    ${this.renderSubscriptions()};
    }

    ${this.renderClientConstructor}

    /**
     * Types
    */

    ${this.renderTypes()}

    /**
     * Type Defs
    */

    const typeDefs = readFileSync(join(__dirname, '${this.typeDefsRelativePath}'), 'utf8')

    /**
     * Exports
     */
    ${this.renderExports(options)}
    `
    return this.format(code, prettifyOptions)
  }

  renderImports () {
    return `\
      // Code generated by Prisma. DO NOT EDIT.

      import { join } from 'path'
      import { readFileSync } from 'fs'
      import { DocumentNode, GraphQLSchema } from 'graphql'
      import { IResolvers } from 'graphql-tools/dist/Interfaces'
      import { Client as BaseClient, BaseClientOptions } from 'prisma-client-lib'
    `
  }
  renderPrismaClassArgs (options) {
    let endpointString = ''
    let secretString = ''
    if (options) {
      if (options.endpoint) {
        endpointString = options.endpoint
          ? `, endpoint: ${options.endpoint}`
          : ''
      }
      if (options.secret) {
        secretString = options.secret ? `, secret: ${options.secret}` : ''
      }
    }

    return `{typeDefs${endpointString}${secretString}}`
  }
  renderExports (options) {
    const args = this.renderPrismaClassArgs(options)
    return `
      export interface PrismaClientOptions extends BaseClientOptions {
        typeDefs ? : string
      }

      export class DB extends BaseClient {
        constructor(options: PrismaClientOptions) {
          super({
            ...${args},
            ...options
          })
        }
      }
    `
  }
}
